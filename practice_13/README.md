# README

## Практическое занятие №13

### Тема: Работа с Promise API. Работа с catch, finally.

Репозитарий содержит материалы по практическому занятию №13, посвященному работе с Promise API, в частности, catch и finally.

### Цели занятия
- закрепление знаний, полученных на лекции;
- разбор практических примеров;
- практическое применение полученных знаний.

### Задачи занятия
1. Вспоминаем промисы. Задача - написать функцию `makeRequest`, которая имитирует загрузку данных товаров с "бэка". Функция должна вернуть промис, который будет зарезолвлен массивом фейковых товаров `fakeProducts` с задержкой в 3 секунды. Результат вывести в консоль.
2. Имитируем получение полноценного ответа от "бэка". Теперь, нам нужно резолвить наш промис из п.1 объектом `successResponse`.
3. Обрабатываем "полноценный ответ". Задача - при вызове функции `makeRequest`, обработать ее результат (она возвращает промис!). У этого результата будет функция `json()`, которая тоже возвращает промис. И уже этот промис, при хорошем раскладе, должен быть зарезолвлен JSON-объектом с данными товаров. Нужно вывести в консоль этот JSON-объект.
4. Добавляем проблем в наше решение. Резолвим наш промис в функции `makeRequest` объектом `failedResponse`. Нужно обработать ситуацию ошибки. Для этого, нам нужно добавить обрабочик `catch` к обработчику промиса (т.е. после then).
5. Реализуем блок `finally`. Задача - после выполнения функции `makeRequest`, независимо от результата, занести в консоль данные о запросе (выводить в консоль следующее: `"Запрос отправлен:" + Date.now()`). Т.е. мы имитируем протоколирование.
6. Расширяем функциональность нашей `makeRequest`. Объект ответа от бэка, в числе прочих полезностей, содержит также поля со статусом ответа (status), и успехом/неуспехом (ok). Нужно изменить наш обработчик ответа так, чтобы при получении неуспешного ответа (`ok !== true`), мы бы генерировали собственную ошибку. Для этого использовать конструкцию `throw new Error('Request failed!');`.
7. Добавляем работу со статусами. Теперь обработчик ответа от "бэка" должен учитывать статус ответа (поле status), и в зависимости от его значения выполнять какие-то действия. Нам нужно проверять 3 самых типичных статуса ответа.
 - 200 (НТТР ОК) - все хорошо. В этом случае нам нужно попытаться разобрать ответ от бэка. Так как мы ожидаем JSON, то нам нужно вернуть результат вызова функции `response.json()`.
 - 401 (HTTP Unauthorized) - не авторизован. Здесь нам нужно кинуть ошибку с текстом `'Unknown user!'`;
 - 500 (HTTP Server Error) - что-то пошло не так на сервере. Нужно кинуть ошибку с текстом `'Something went wrong!'`;
8. Заменяем работу с фейковым объектом на реальный `fetch`. Работаем со списком товаров. Т.е. теперь, наша функция вместо своей задержки должна по-честному обратиться к бэку за списком товаров (адрес - `https://fakestoreapi.com/products`).
9. Добавляем показ иконки загрузки перед отправкой запроса. Спрятать ее необходимо в любом случае, после отработки запроса (вне зависимости от результатов).

### Полезные ссылки по занятию:
Спецификация [fetch](https://developer.mozilla.org/en-US/docs/Web/API/fetch) на MDN - англоязычная.
Подробный гайд по [Promise API](https://learn.javascript.ru/promise-basics) - русскоязычный.
Статья с примерами по использованию [Promises](https://www.freecodecamp.org/news/javascript-promise-tutorial-how-to-resolve-or-reject-promises-in-js/) - англоязычная. Включает в чебя также параллельное выполнение (`all`, `race`, `any`, и т.д.)