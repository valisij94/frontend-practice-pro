# README

## Практическое занятие №18

### Тема:

Репозитарий содержит материалы по практическому занятию №18, посвященному продолжению темы ООП в JavaScript

### Цели занятия
- закрепление знаний, полученных на лекции;
- разбор практических примеров;
- практическое применение полученных знаний.

### Задачи занятия
1. Продолжаем работать с интернет-магазином инструментов. В файле main.js уже построена иерархия классов (из прошлого занятия). Добавим в класс `Product` приватное свойство puchasePrace (закупочная цена). В конструктор класса добавьте инициализацию - закупочная цена должна равняться 0.75 от цены товара (`price`).
2. Добавим свойство-геттер для purchasePrice. Нам нужно сделать так, чтобы при обращении к свойству purchasePrice объекта товара, возвращалось бы значение приватного свойства purchasePrice (определенного в п.1.)
3. Делаем сеттер. Нужно добавить в класс `Product` свойство-сеттер purchasePrice, при изменении которого должно изменяться значение приватного свойства из п.1.
4. Добавляем логику в сеттер. Нужно обеспечить такое поведение: если новое значение закупочной цены больше текущей цены товара - то нужно кинуть ошибку "Закупочная цена больше цены товара!".
5. Добавляем свойство-геттер `shortDescription`. При обращении к нему, мы хоти получать строковое представление товара вида "Товар НАЗВАНИЕ_ТОВАРА, цена - ЦЕНА_ТОВАРА".
6. Работаем со свойствами объектов и методами класса Object. Создадим объект класса `PowerTool`. Название - Saw, цена - 250, ИД - 1, описание - Electric Saw, мощность - 2500, гарантийный срок - 3 года. Нужно вывести все свойства и значения этого объекта в консоль, следующим образом: "Свойство НАЗВАНИЕ_СВОЙСТВА, значение - ЗНАЧЕНИЕ_СВОЙСТВА". Использовать методы класса `Object`.
7. Создайте и запишите в переменную saw2 независимую копию объекта Saw (так, чтобы при изменении свойств saw2, свойства исходного объекта не затрагивались). Для создания копии также используем методы класса `Object`.
8. Пишем свою функцию поверхностного копирования. Нужно написать функцию, которая принимает объект, и создает его поверхностную копию. ВАЖНО - не использовать методы класса `Object`. Как нужно действовать:
 - пройтись циклом по всем свойствам объекта-оригинала
 - в объект-копию записать аналогичные свойства объекта-оригинала, с таким же значением.
9. Снова работаем со свойствами объектов и методами класса `Object`. У нас есть объект `orders`, в котором содержится информация о заказах. Информация хранится в виде пар ключ-значение, где в роли ключа выступает ИД пользователя, оставившего заказ, а в роли значения - массив с объектами товаров, которые заказаны пользователем. Нужно построить объект `ordersTotal`, в котором будут данные по общему кол-ву товаров, заказанных пользователями.
```
const saw = new PowerTool(1, 'Saw', 150, 'Saw. Just the saw', 1500, 3);
const hammer = new Tool(2, 'Hammer', 55, 'Steel hammer', 55);
const drill = new PowerTool(3, 'Drill', 120, 'Bosch Drill', 2000, 2);
const shovel = new Tool(4, 'Shovel', 80, 'Steel Shovel', 50);

const orders = {
    'user1': [saw, hammer],
    'user2': [hammer],
    'user3': [drill, shovel],
    'user4': [shovel]
}

// Expected result
ordersTotal: {
    'user1' : 2,
    'user2' : 1,
    'user3' : 2,
    'user4' : 1
}
```
Как действуем:
 - нужно создать объект-контейнер ordersTotal
 - нам нужно пройтись по ключам и значениям свойств объекта - в этом поможет метод `Object.entries`, который нам возвращает массив из массивов вида [key, value].
 - идем по свойствам объекта orders. В объект-контейнер пишем свойство с таким же ключом (key), а в качестве значения - ставим кол-во товаров в массиве (value.length)
9. Усложняем задачу. Теперь нужно в объект ordersTotal записать суммарную стоимость товаров, заказанных пользователем.
10. Задача повышенного уровня сложности. Пишем свою функцию для глубокого копирования несложных объектов. Наша функция должна принимать объект, и возвращать независимую копию. При этом, если в свойствах объекта есть другие объекты, то эти объекты также должны быть независимы от "оригинала". Как нужно действовать:
 - нужен цикл по свойствам объекта-оригинала
 - если тип свойства объекта-оригинала - не объект, то просто переносим его в объект-копию с тем же именем.
 - если тип свойства объекта-оригинала - объект, то создаем его "неглубокую" копию методом `Object.assign`, и эту копию пишем в объект-копию с тем же именем свойства.


### Полезные ссылки по занятию:
 - Спецификация MDN по [приватным свойствам](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Private_class_fields)
 - Русскоязычный гайд по [свойствам-аксессорам](https://learn.javascript.ru/property-accessors)
 - Распространенные методы класса [Object](https://learn.javascript.ru/keys-values-entries)