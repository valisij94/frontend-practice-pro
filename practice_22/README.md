# README

## Практическое занятие №22

### Тема:

Репозитарий содержит материалы по практическому занятию №22, посвященному браузерным и интерфейсным событиям.

### Цели занятия
- закрепление знаний, полученных на лекции;
- разбор практических примеров;
- практическое применение полученных знаний.

### Задачи занятия
1. Пишем функцию валидации текстового поля `validateInput`. Она должна принимать объект Event, и проверять, что поле не пустое (т.е там введено какое-либо значение). Если поле пустое - применяем к полю класс error-input. Если непустое - убираем этот класс.
2. Добавляем обработчик на событие `focusout` у инпута `input#titleInput`.
3. Усложняем задачу. Нам нужно на все инпуты, которые обязательны к заполнению, добавить валидацию на непустоту. У всех инпутов, обязательных к заполнению, есть атрибут `data-required`. То есть, нам нужно:
 - пройтись по всем инпутам в документе
 - у каждого инпута проверить наличие атрибута `data-required`.
 - если такой атрибут есть - то на событие `focusout` добавляем обработчик - `validateInput`.
 - если такого атрибута нет - ничего не делаем.
4. Пишем функцию `checkNumber` - она должна принять объект event, и проверить, является ли `event.target.value` числом. Используем `isNaN`. Если число - то возвращаем `true`, иначе - `false`.
5. Задача со звездочкой (обсуждаем и потом решаем). Нам нужно добавить валидацию введенного числа в инпуты с ИД `amountInput`, `countInput`. Валидировать также нужно на событие `focusout`. Это можно сделать или отдельным обработчиком, или доработать решение задачи 3.
6. Вспоминаем `preventDefault`. У нас под инпутами, есть кнопка "Отправить". Кнопка относится к форме с инпутами, и должна отправлять форму на сервер.
 - добавить обработчик на событие клика на эту "кнопку".
 - при клике на кнопку, нужно проверять, есть ли у нас невалидные инпуты (например, поискать в форме элементы с классом `error-input`). если у нас есть невалидные инпуты - предотвращаем поведение по умолчанию.
7. Работаем со всплытием событий - добавляем подобие своей аналитики. Нам нужно отслеживать события клика по кнопкам, и ввода в текстовые поля, и записывать их в объект-хранилище (он уже создан, `storageObject`). Нужно написать такой блок кода, который будет отслеживать все клики по кнопкам и ввод в текстовые поля в документе, и при наступлении такого события он будет увеличивать соответствующий счетчик в объекте `storageObject`. В этом нам поможет то, что события всплывают - то есть нам нужно добавлять наш слушатель таких событий на уровень документа. При этом важно не считать события, которые не относятся к инпутам и кнопкам (надо проверять `event.target`).
8. Работаем с событиями мыши. Мы хотим добавить "счетчик времени", когда пользователь зажимает левую кнопку мыши (ЛКМ). То есть, когда пользователь нажимает ЛКМ, мы запускаем счетчик. Когда отпускает ЛКМ - останавливаем счетчик и выводим в консоль время в миллисекундах, пока ЛКМ была зажата. Как это сделать:
 - нас интересуют события `mousedown`, `mouseup`.
 - нам интересны все события в документе - а значит обработчик пишем на уровне документа
 - сам "счетчик" имеет смысл объявить вне обработчиков (чтобы он был доступен обоим обработчикам)
 - при событии `mousedown` фиксируем текущее время (`Date.now()`) в наш "счетчик"
 - при событии `mouseup`, нам нужно определить текущее время (`Date.now()`), и вывести в консоль разницу между текущим временем, и временем события `mousedown`s

### Полезные ссылки по занятию:
 - Спецификация MDN по [объекту Event](https://developer.mozilla.org/ru/docs/Web/API/Event/Event)
 - Раздел учебника, посвященный [браузерным событиям](https://learn.javascript.ru/ui) - много чтива, но оно стоит каждой потраченной минуты.