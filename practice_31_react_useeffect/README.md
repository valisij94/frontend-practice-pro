# README

## Практическое занятие №31

### Тема:

Репозитарий содержит материалы по практическому занятию №31, посвященному работе с хуком useEffect (закреплению знаний и практике работы с эффектами).

### Цели занятия
- закрепление знаний, полученных на лекции;
- разбор практических примеров;
- практическое применение полученных знаний.

### Задачи занятия
1. Вспоминаем применение эффектов. Задача - при ПЕРВОМ рендере компонента `LoginForm` выводить в консоль сообщение "login form is mounted", а перед размонтированием компонента - выводить сообщение "login form will be unmounted".
2. Дорабатываем компонент `ProductItem`. Задача - добавить обработчик клика на кнопку "Добавить в корзину". При клике на кнопку, нужно отправлять запрос на `https://fakestoreapi.com/products/{productId}`. Этот `productId` приходит в компонент `ProductItem` в пропсах, свойство product.id. Нужно выполнять асинхронный код в `useEffect`. Подсказка: чтобы запускать наш эффект по клику, нам может помочь `useState`.
3. Работаем с `localStorage`. Наша задача - сделать так, чтобы данные пользователя в компоненте `LoginForm` не потерялись при обновлении им страницы. То есть, нужно сохранить в `localStorage` сериализованные данные формы. Используем ключ `loginFormData`. C `localStorage` мы также работаем в эффекте. Нужно обеспечить сохранение данных формы на каждое обновление значений в инпутах login, password.
4. Теперь нужно обеспечить использование этих данных. То есть, при ПЕРВОМ рендеринге компоеннта проверить, есть ли в `localStorage` данные формы. Если есть - заполнить ими локальный стейт формы.
5. Вспоминаем работу с таймаутами. У нас компонент `Greeting` рендерится по клику на кнопку. Нужно сделать так, чтобы через 10 секунд после рендеринга, компонент менял цвет фона на `#0096CD`. И также нужно не допуустить, чтобы этот таймер срабатывал, если компонент уже размонтирован. Подсказка - мы также работаем в useEffect, нужно не забыть функцию очистки.
6. Задача повышенной сложности. Делаем "кастомный указатель" на компоненте `App`. Нужно сделать так, чтобы мышку cопровождал красный кружок. Радиус - 20 пикселей. Как это сделать:
 - это должен быть абсолютно позиционированный div
 - красный цвет обеспечим фоном, круглую форму - через `border-radius`
 - его позиция должна соответствовать позиции мыши - значит, нам нужно отслеживать событие `pointermove`
 - обработчик на это событие должен быть добавлен при ПЕРВОМ рендеринге компонента
 - нужно не забыть "очистить" компонент пи размонтировании
 - координаты мышки нужно хранить в стейте

### Полезные ссылки по занятию:
 - [React useEffect](https://react.dev/reference/react/useEffect#updating-state-based-on-previous-state-from-an-effect) - толковая официальная документация по `useEffect`. С интерактивными примерами, поэтому настоятельно рекомендуется к просмотру. Кое-что там можно проигнорировать (например использование анимации), но в целом дает представление о том, зачем это.
 - [React useEffect](https://ru.legacy.reactjs.org/docs/hooks-effect.html) - устаревшая, зато русскоязычная документация. Она все еще актуальна, логика работы хука никак не изменилась, так что можно рассмотреть.
