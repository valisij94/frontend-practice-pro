# README

## Практическое занятие №7

### Тема: Замыкания

Репозитарий содержит материалы по практическому занятию №7 - замыканиям.

### Цели занятия
- закрепление знаний, полученных на лекции;
- решение задач.

### Задачи занятия
В процессе занятия, предполагается решение задач на тему "Замыкания", для понимания концепций области видимости, лексического окружения.

### Список задач на занятие, и для самостоятельного выполнения
1. Задача на области видимости
```
for (let i = 0; i < 10; i++) {
  console.log('Iteration ' + i);
}
console.log('Now our iterator is: ' + i);
// Здесь что-то не работает. Почему?
// Как сделать так, чтобы работало?
// Что будет, если вместо let мы используем var?
```
2. Задача на области видимости чуть сложнее
```
function outerFunction(text) {
  const outerProperty = 'Outer Property';
  // 1
  function innerFunction() {
    // 2
    const innerProperty = 'Inner';
    console.log(`${innerProperty} ${text}`)
  }
  // 3
  innerFunction();
  // 4
}
// 5
outerFunction('TextArgument');
// Что выведет код?
// Что будет, если на месте метки 1 вызвать innerFunction?
// Что будет, если в точке 2 поставить console.log(outerProperty)?
// Что будет, если в точке 3 поставить console.log(outerProperty)?
// Что будет, если в точке 4 поставить console.log(innerProperty)?
// Что будет, если в точке 5 поставить console.log(innerProperty)?
// Что будет, если в точке 5 поставить console.log(outerProperty)?
```
3. Пишем функцию counter. Она должна считать число своих запусков. Функция должна вернуть другую функцию, которая увеличивает значение счетчика на 1, и выводит его в консоль.

4. Написать функцию-"фабрику", которая будет делать функции, умножающие на произвольное число. То есть, функция принимает аргумент multiplier (первый множитель) и возвращает другую функцию, которая принимает аргумент num - второй множитель. Результатом должно быть произведение множителей.

5. Написать функцию, которая возвращает сумму двух аргументов, но при этом должна вызываться так: sum(a)(b). Пример:
```
let result = sum(2)(8); // Ожидаемый результат - 10.
```

6. Написать функцию кэширования. Предположим, у нас есть функция, которая выполняет сложные и долгие математические вычисления для одного аргумента (вычисление факториала). Задача повышенной сложности.
```
function factorial(a) {
  let result = 1;
  for (let i = 1; i <= a; i++) {
    result = result * i;
  }
  return result;
}
```
Нужно написать функцию-"обертку", которая будет вести кэш. То есть, нам нужно при каждом вызове функции factorial, запоминать в этот "кэш" аргумент этой функции, и результат. Если при вызове функции factorial мы видим что аргумент есть в кэше - то возвращаем значение из кэша. Если в кэше такого значения нет - то вычисляем ответ, возвращаем его, и также запоминаем в кэш.
 - для кэша, рекомендуется использовать объект, в котором ключами будут аргументы функции-факториала
 - проверка существования свойства в объекте, когда название свойства неизвестно:
 ```
 let obj = { prop1: 'val1', prop2: 'val2' };
 console.log(obj['prop1']); // выведет val1
 console.log(obj['prop100']); // выведет undefined
 ```

### Полезные ссылки
- [Очень полезный русскоязычный гайд](https://learn.javascript.ru/closure) по замыканиям. Перед собеседованиями категорически рекомендуется!
- [Еще русскоязычный гайд](https://habr.com/ru/companies/ruvds/articles/424967/) по замыканиям. Тут тоже есть наглядные примеры, но изложено чуть сложнее.
